% Font parameters

% This is the font ZMSY10, containing special symbols used by Zohar Manna.
% It has been worked on by several people, notably:
%
%   Frank Yellin, who converted it from old MF to new MF;
%   Eric Muller, who added various symbols;
%   Joe Weening, who added more symbols, modified some existing ones,
%	and cleaned up various things.
%   Eric Muller, who added some more symbol and tried to convert the thing
%       to use Metafont 2.0. Added Min{C,B,D}.

% Last modified on Wed Nov  6 14:36:40 PST 1991 by muller


if unknown cmbase: input cmbase fi

%% ke 11.11.1999: waits isn't found by metafont (probably using kpathsea),
%%                however, it seems to be redundant anyway, at least in
%%                the teTeX-1.0 I'm using.
%%input waits

%\mode:=imagen;
%mag:=magstep(0);

%\mode:=crs;
%mag := 1.8;

font_identifier:="ZMSY"; font_size 10pt#;

u#:=20/36pt#;			% unit width
width_adj#:=0pt#;		% width adjustment for certain characters
serif_fit#:=0pt#;		% extra sidebar near lowercase serifs
cap_serif_fit#:=5/36pt#;	% extra sidebar near uppercase serifs
letter_fit#:=0pt#;		% extra space added to all sidebars

body_height#:=270/36pt#;	% height of tallest characters
asc_height#:=250/36pt#;		% height of lowercase ascenders
cap_height#:=246/36pt#;		% height of caps
fig_height#:=232/36pt#;		% height of numerals
x_height#:=155/36pt#;		% height of lowercase without ascenders
math_axis#:=90/36pt#;		% axis of symmetry for math symbols
bar_height#:=87/36pt#;    % height of crossbar in lowercase e
comma_depth#:=70/36pt#;		% depth of comma below baseline
desc_depth#:=70/36pt#;    % depth of lowercase descenders

crisp#:=8/36pt#;		% diameter of serif corners
tiny#:=8/36pt#;			% diameter of rounded corners
fine#:=7/36pt#;			% diameter of sharply rounded corners
thin_join#:=7/36pt#;		% width of extrafine details
hair#:=9/36pt#;			% lowercase hairline breadth
stem#:=24/36pt#;		% lowercase stem breadth
curve#:=29/36pt#;		% lowercase curve breadth
ess#:=27/36pt#;			% breadth in middle of lowercase s
flare#:=32/36pt#;		% diameter of bulbs or breadth of terminals
dot_size#:=38/36pt#;		% diameter of dots
cap_hair#:=11/36pt#;		% uppercase hairline breadth
cap_stem#:=30/36pt#;		% uppercase stem breadth
cap_curve#:=35/36pt#;		% uppercase curve breadth
cap_ess#:=33/36pt#;		% breadth in middle of uppercase s
rule_thickness#:=.4pt#;		% thickness of lines in math symbols

dish#:=1/36pt#;			% amount erased at top or bottom of serifs
bracket#:=20/36pt#;		% vertical distance from serif base to tangent
jut#:=30/36pt#;			% protrusion of lowercase serifs
cap_jut#:=37/36pt#;		% protrusion of uppercase serifs
beak_jut#:=10/36pt#;		% horizontal protrusion of beak serifs
beak#:=70/36pt#;		% vertical protrusion of beak serifs
vair#:=8/36pt#;			% vertical diameter of hairlines
notch_cut#:=10pt#;		% maximum breadth above or below notches
bar#:=11/36pt#;			% lowercase bar thickness
slab#:=11/36pt#;		% serif and arm thickness
cap_bar#:=11/36pt#;		% uppercase bar thickness
cap_band#:=11/36pt#;		% uppercase thickness above/below lobes
cap_notch_cut#:=10pt#;		% max breadth above/below uppercase notches
serif_drop#:=4/36pt#;		% vertical drop of sloped serifs
stem_corr#:=1/36pt#;		% for small refinements of stem breadth
vair_corr#:=1/36pt#;		% for small refinements of hairline height
apex_corr#:=0pt#;		% extra width at diagonal junctions

o#:=8/36pt#;			% amount of overshoot for curves
apex_o#:=8/36pt#;		% amount of overshoot for diagonal junctions

slant:=0;			% tilt ratio $(\Delta x/\Delta y)$
fudge:=1;			% factor applied to weights of heavy characters
math_spread:=0;			% extra openness of math symbols
superness:=1/sqrt2;		% parameter for superellipses
superpull:=1/6;			% extra openness inside bowls
beak_darkness:=11/30;		% fraction of triangle inside beak serifs
ligs:=2;			% level of ligatures to be included

square_dots:=false;		% should dots be square?
hefty:=false;			% should we try hard not to be overweight?
serifs:=true;			% should serifs and bulbs be attached?
monospace:=false;		% should all characters have the same width?
variant_g:=true;		% should an italic-style g be used?
low_asterisk:=false;		% should the asterisk be centered at the axis?
math_fitting:=true;		% should math-mode spacing be used?

subs:=7/10;  % subscripts to 10pt will normally be in 7pt type
rth#:=.4pt#;  % assume that rules will come from cmex10
fontdimen 8:  % parameters $\sigma_8$ through $\sigma_{22}$ will now be listed
 math_axis#+3.51rth#+54/36pt#+subs*desc_depth#,      % num1
 math_axis#+1.51rth#+30/36pt#,          % num2
 math_axis#+1.51rth#+48/36pt#,          % num3
 -(math_axis#-3.51rth#-subs*fig_height#-124/36pt#),    % denom1
 -(math_axis#-1.51rth#-subs*fig_height#-30/36pt#),    % denom2
 8.99pt#-subs*asc_height#,          % sup1
 8.49pt#-subs*asc_height#,          % sup2
 104/36pt#,              % sup3
 54/36pt#,              % sub1
 -(8.49pt#-2subs*asc_height#-3.1rth#),        % sub2
 subs*asc_height#-36/36pt#,          % sup\_drop
 18/36pt#,              % sub\_drop
 23.9pt#,              % delim1
 10.1pt#,              % delim2
 math_axis#;              % axis\_height

mode_setup; font_setup;

warningcheck:=0;

% Later in this file, we read in CMBASE.MF, which redefines some macros
% that are used before it is read.  To make this work, we begin a group
% here, use "save" for all macros that are redefined, and end the group
% before reading CMBASE.

begingroup;

math_axis# := 2.5pt#;		% height of math axis (same as CM fonts)

asc_height#:=250/36pt#;		% height of lowercase ascenders
body_height#:=270/36pt#;	% height of tallest characters
x_height#:=155/36pt#;		% height of lowercase without ascenders
bar_height#:=87/36pt#;		% height of crossbar in lowercase e
desc_depth#:=70/36pt#;		% depth of lowercase descenders
define_pixels (asc_height, body_height, x_height, bar_height, desc_depth);

% Standard pen widths.  Originally each page of this file defined
% its own pens.  Now we try to make things look more uniform.

thin_pen_width#  :=  .5pt#;	% for thin lines
thick_pen_width# :=  .8pt#;	% for thick lines
heavy_pen_width# := 1.0pt#;	% for very thick lines

define_blacker_pixels(thin_pen_width, thick_pen_width, heavy_pen_width);

% Macros from CMBASE used in this font

save v_center;
def v_center(expr h_sharp) =
 .5h_sharp+math_axis#, .5h_sharp-math_axis# enddef;

% More macros

circle_mid_ht# := 4pt#;
circle_radius# := 11pt#;

define_pixels(circle_mid_ht, circle_radius);

boolean draw_big_loop, draw_big_ellipse;

draw_big_loop := true;
draw_big_ellipse := true;

def flipx(expr y) = 
    begingroup save T; transform T;
    T  = identity yscaled -1 shifted (0, 2y);
    T endgroup enddef;

def flipy(expr x) = 
    begingroup save T; transform T;
    T  = identity xscaled -1 shifted (2x, 0);
    T endgroup enddef;

def draw_triangle(expr point, length, height, penwidth) =
    1/2[z1,z2] = point + (length, 0);	%	1
    z1 = z2 + (0, height);		% pt
    pickup pencircle scaled penwidth;	%	2
    draw point -- z1 -- z2 -- cycle;
enddef;
% special right arrow		(l)

bz# := 1.5pt#;
define_pixels(bz);

%%%%%%%%%beginchar(hex "6C", 36bz#, 9bz#, 0)
%%%%%%%%%z1 = origin;
%%%%%%%%%z2 = (16bz, 7bz);
%%%%%%%%%z3 = (21bz, 8.5bz);
%%%%%%%%%z4 = (18bz, 5bz);
%%%%%%%%%z5 = (14bz, 1bz);
%%%%%%%%%z6 = (21bz, 3bz);
%%%%%%%%%z7 = (36bz, 9bz);
%%%%%%%%%z8 = (28bz, y7);
%%%%%%%%%z9 = (29bz, y7-6bz);
%%%%%%%%%
%%%%%%%%%pickup pencircle scaled heavy_pen_width;
%%%%%%%%%draw z1..z2..z3..z4..z5..z6..z7;
%%%%%%%%%draw z9--z7--z8;
%%%%%%%%%
%%%%%%%%%penlabels(1,2,3,4,5,6,7,8,9);
%%%%%%%%%endchar;

% ellipticals			circle(c) ellipse(d) long ellipse(s)

def docircle(expr code, name, thewidth_pt) =
    beginchar(code, 2 thewidth_pt, 
		    circle_mid_ht# + circle_radius#, 
		    circle_radius# - circle_mid_ht#);
    name;
    thewidth# := thewidth_pt;
    define_pixels(thewidth);
    pickup pencircle scaled thin_pen_width;	%    2
    rt z3 = lft z1 + (2 thewidth, 0);		%  1   3
    top z2 = bot z4 + (0, 2 circle_radius);	%    4
    1/2 [z1, z3] = 1/2[z2, z4] =  (thewidth, circle_mid_ht);
    draw z1{up} .. z2{right} .. z3{down} .. z4{left} .. cycle;
    penlabels(1, 2, 3, 4);
    endchar;
enddef;
 
docircle(hex "63", "circle", circle_radius#);
docircle(hex "64", "ellipse", 15pt#);
%%%%%%%%%if draw_big_ellipse: docircle(hex "73", "long ellipse", 20pt#); fi
% loop parameters and subroutines

% loop subroutine

def draw_a_loop(expr hradius, vradius, extrax) =
    pickup pencircle scaled thin_pen_width;
    lft z3 = (0, midline);
    x2 = x4 = hradius;			%	2
    .5[y2, y4] = midline;		% 		1
    top y2 = midline + vradius;		% 3
					% 		5
    x1 = x5 = x2 + extrax;		%	4
    .5[y1, y5] = midline;
    y1 - midline = vradius * (1 +-+ extrax/hradius);
    
    draw z1{-1.8, 1}..z2{left}..z3{down}..z4{right}..z5{1.8,1};

    z1 = z6 + (3.5pt, 1pt);			%     7
    z6 - z1 = (z7 - z1) rotated 90;		%
    pickup pencircle scaled thick_pen_width;	%	1
    draw z6 -- z1 -- z7;			% 6
    penlabels(1,2,3,4,5,6,7);
enddef;

midline# := circle_mid_ht#;
shortaxis# := 8pt#;
longaxis# := 13pt#;
hlength# := 23.5pt#;		% total horizontal length

define_pixels(midline, shortaxis, longaxis, hlength);

picture p;

beginchar(hex "65", hlength#, midline# + shortaxis#, shortaxis# - midline#);
draw_a_loop(longaxis, shortaxis, hlength - longaxis);
p := currentpicture;
endchar;

beginchar(hex "66", hlength#, midline# + shortaxis#, shortaxis# - midline#);
currentpicture := p transformed flipx(midline);
endchar;

beginchar(hex "67", hlength#, midline# + shortaxis#, shortaxis# - midline#);
currentpicture := p transformed(flipx(midline) transformed flipy(hlength/2));
endchar;

beginchar(hex "68", hlength#, midline# + shortaxis#, shortaxis# - midline#);
currentpicture := p transformed flipy(hlength/2);
endchar;

transform T;
T := identity rotated 90 shifted (whatever, whatever);
(longaxis, midline) transformed T = (shortaxis, 0);

beginchar(hex "5B", 2.shortaxis#, hlength# - longaxis#, longaxis#);
"loop facing down";
currentpicture := p := p transformed T;
endchar;

beginchar(hex "5A", 2.shortaxis#, longaxis#, hlength# - longaxis#);
"loop facing up";
currentpicture := p yscaled -1;
endchar;


% Now we go into the big loops.  We really just steal some of
% the above code!

if draw_big_loop:

shortaxis# := 8pt# * 1.5;
longaxis# := 13pt# * 1.5;
hlength# := 23.5pt# * 1.5;	% total horizontal length

define_pixels(midline, shortaxis, longaxis, hlength);

%%%%%%%%%beginchar(hex "74", hlength#, midline# + shortaxis#, shortaxis# - midline#);
%%%%%%%%%draw_a_loop(longaxis, shortaxis, hlength - longaxis);
%%%%%%%%%p := currentpicture;
%%%%%%%%%endchar;

beginchar(hex "75", hlength#, midline# + shortaxis#, shortaxis# - midline#);
currentpicture := p transformed flipx(midline);
endchar;

%%%%%%%%%beginchar(hex "76", hlength#, midline# + shortaxis#, shortaxis# - midline#);
%%%%%%%%%currentpicture := p transformed(flipx(midline) transformed flipy(hlength/2));
%%%%%%%%%endchar;

%%%%%%%%%beginchar(hex "77", hlength#, midline# + shortaxis#, shortaxis# - midline#);
%%%%%%%%%currentpicture := p transformed flipy(hlength/2);
%%%%%%%%%endchar;

fi
% triangles			tril(a) trir(b);

width# := 3.2pt#;
bottom# := .565pt#;
margin# := .565pt#;
height# := 1.88pt#;
penwidth# := .282pt#;

define_pixels(width, bottom, margin, height);
define_blacker_pixels(penwidth);

picture p;

beginchar(hex "61", 2 margin# + width#, bottom# + height#, 0);
"triL";
draw_triangle( (margin, bottom + height/2), width, height, penwidth);
p := currentpicture;
endchar;


beginchar(hex "62", 2 margin# + width#, bottom# + height#, 0);
"triR";
currentpicture := p transformed flipy(margin + width/2);
endchar;
% arrow heads			left(j)  right(i)

% in these arrowheads, the "point" of the triangle is the reference point of
% the box.

height# := 2pt#;
width# := 3pt#;

define_pixels(height, width)

picture p;

beginchar(hex "69", 0, height#, height#);
"right arrow head";
draw_triangle(origin, -width, 2 height, heavy_pen_width);
p := currentpicture;
endchar;

beginchar(hex "6A", 0, height#, height#);
"left arrow head";
currentpicture := p xscaled -1;
endchar;

% pointer			left(k) right(m) rt solid (n), lft sold (o)

height# := 4pt#;
width# := 5pt#;
middle# := 3pt#;

define_pixels(height, width, middle);

picture p;

beginchar(hex "6B",  width#, middle# + height#/2, 0);
"left pointer";
draw_triangle( (width, middle), -width, height, heavy_pen_width);
p := currentpicture;
endchar;


beginchar(hex "6D",  width#, middle# + height#/2, 0);
"right pointer";
currentpicture := p transformed flipy (width/2);
endchar;

beginchar(hex "6E", width#, middle# + height#/2, 0);
"right solid pointer";

x1 = x2 = width;		% 	1
z3 = (0, middle);		% 3
				%	2
.5[y1,y2] = middle;
y1 - y2 = height;
fill z1 -- z2 -- z3 -- cycle;
p := currentpicture;
endchar;


beginchar(hex "6F", width#, middle# + height#/2, 0);
"left solid pointer";
currentpicture := p transformed flipy(width/2);
endchar;

clearit;
% bowed lines			(A -- I)

height# := 5pt#;
alength# := 60pt#;
blength# := 72pt#;		% ditto
bottom_ht# := 9pt#;
flipper# := circle_mid_ht#;	% see global constants

define_pixels(height, alength, blength, bottom_ht, flipper);

picture p[];

% we're actually going to have the arrows extend slightly out the boxes on
% either side so that they will barely touch a circle if it is placed next
% to it.  


fudgea = circle_radius - (circle_radius +-+ (bottom_ht - flipper));

def draw_bowed_line(suffix p)(expr wd) =
    numeric x[], y[];
    p.width# := wd;
    define_pixels(p.width);
    pickup pencircle scaled thin_pen_width;
    lft z1 = (-fudgea, bottom_ht);		%	     2
    rt z3 = (p.width+fudgea, bottom_ht);		%
    x2 = .5[x1, x3];				% 1			3
    y2 = bottom_ht + height;
  
    draw z1 .. z2{right} .. z3;

    pickup pencircle scaled thick_pen_width;	%      5
    z4 - z3 = (z5 - z3) rotated 90;		%
    z5 = z3 + (-1pt, 3.5pt);			%	3
    draw z5 -- z3 -- z4;			% 4
    p := currentpicture;
    clearit;
    penlabels(1,2,3,4,5);
enddef;

%%%%%%%%%draw_bowed_line(p1, alength#);
%%%%%%%%%draw_bowed_line(p2, blength#);

def topbowline(expr char, name)(suffix p) =
    beginchar(char, p.width#, bottom_ht# + height#, 0);
    name;
    currentpicture := p;
    endchar;
enddef;

def botbowline(expr char, name)(suffix p) =
    beginchar(char, p.width#, 0, bottom_ht# + height# - 2 flipper#);
    name;
    currentpicture := p transformed flipx(flipper);
    endchar;
enddef;

% if false:

%%%%%%%%%"bowlines pointing right";
%%%%%%%%%topbowline(hex "5C", "1", p1);
%%%%%%%%%topbowline(hex "5D", "2", p2);
%%%%%%%%%botbowline(hex "43", "3", p1);
%%%%%%%%%botbowline(hex "44", "4", p2);

% fi

%%%%%%%%%p1 := p1 transformed flipy(p1.width/2);
%%%%%%%%%p2 := p2 transformed flipy(p2.width/2);

%%%%%%%%%"bowlines pointing left";
%%%%%%%%%topbowline(hex "45", "1", p1);
%%%%%%%%%topbowline(hex "46", "2", p2);
%%%%%%%%%botbowline(hex "47", "3", p1);
%%%%%%%%%botbowline(hex "48", "4", p2); 


transform t;
t = identity rotated 90 shifted (whatever, whatever);
(0, bottom_ht) transformed t = (height, 0);

%%%%%%%%%p1 := p1 transformed t;
%%%%%%%%%p2 := p2 transformed t;


def side_bow_line(expr char, name)(suffix p)(expr flx, fly) =
beginchar(char, height# + flipper#, p.width#, 0);
    transform t;
    name;
    t := identity;
    if flx:   t := t transformed flipx(p.width/2); fi
    if fly:   t := t transformed flipy((flipper + height)/2); fi
    currentpicture := p transformed t;
endchar;
enddef;

%%%%%%%%%side_bow_line(hex "49", "1", p1, false, false);
%%%%%%%%%side_bow_line(hex "4A", "2", p2, false, false);
%%%%%%%%%side_bow_line(hex "4B", "3", p1, true, false);
%%%%%%%%%side_bow_line(hex "4C", "4", p2, true, false);
%%%%%%%%%side_bow_line(hex "4D", "5", p1, false, true);
%%%%%%%%%side_bow_line(hex "4E", "6", p2, false, true);
%%%%%%%%%side_bow_line(hex "4F", "7", p1, true, true);
%%%%%%%%%side_bow_line(hex "50", "8", p2, true, true);

%%%%%%%%%ligtable hex "5C": hex "43": hex "45": hex "47":
%%%%%%%%%	hex "5C" kern -alength#,
%%%%%%%%%	hex "43" kern -alength#,
%%%%%%%%%	hex "45" kern -alength#,
%%%%%%%%% 	hex "47" kern -alength#;
%%%%%%%%%ligtable hex "5D": hex "44": hex "46": hex "48":
%%%%%%%%%	hex "5D" kern -blength#,
%%%%%%%%%	hex "44" kern -blength#,
%%%%%%%%%	hex "46" kern -blength#,
%%%%%%%%%	hex "48" kern -blength#;
% turnstiles			1 spoke(p)  2 spoke (q)  3 spoke (r)

height# := 6pt#;
margin# := 1pt#;
width# := 4pt#;

define_pixels(height, margin, width);

def do_turnstile(expr char, i) =
beginchar(char, width# + margin#, height#, 0);
    "turnstile " & decimal i;
    pickup pencircle scaled thick_pen_width;
    z1 = (margin, 0); z2 = (margin, height);
    draw z1 -- z2;
    for j := 1 step 1 until i:
	z[j].a = (margin, height * j/(i+1));
	z[j].b = z[j].a + (width, 0);
	draw z[j]a -- z[j]b;
    endfor;
endchar; enddef;


do_turnstile(hex "70", 1);
do_turnstile(hex "71", 2);
do_turnstile(hex "72", 3);

% support			1 spoke but 2 vertical lines

height# := 6pt#;
margin# := 1pt#;
width# := 6pt#;

define_pixels(height, margin, width);

def do_support(expr char, i) =
beginchar(char, width# + margin#, height#, 0);
    "support " & decimal i;
    pickup pencircle scaled thick_pen_width;
    for j := 1 step 1 until i:
	z[j].a = (margin + (j-1)* width/4, 0);
	z[j].b = z[j].a + (0, height);
	draw z[j]a -- z[j]b;
    endfor;
    z1 = (margin + (i-1) * width/4 , height/2); z2 = (margin+width, height/2);
    draw z1 -- z2;
endchar; enddef;

do_support(hex "73", 2);
% funny outer brackets		left (x)  right (y)

barbottom# := -38pt#/18;
bartop# := 128pt#/18;
width# := 3pt#;
margin# := 1pt#;
penwidth# := 1.2pt#;

define_pixels(barbottom, bartop, width, margin);
define_blacker_pixels(penwidth);

barbottom - thebottom = thetop - bartop = 2pt;

picture p;

beginchar(hex "78", width# + margin#, bartop# + 2pt#, 2pt# - barbottom#);
    "left funny outer bracket";

    z1 = (0, barbottom);		%       4
    z2 = (0, bartop);                   % 2
    z3 = (width, thebottom);            %
    z4 = (width, thetop);		% 1
					%       3
    pickup pencircle scaled penwidth;
    draw z4 -- z2 -- z1 -- z3;
    p := currentpicture;
endchar;


beginchar(hex "79", width# + margin#, bartop# + 2pt#, 2pt# - barbottom#);
    "right funny outer bracket";
    currentpicture := p transformed flipy( (width + margin)/2);
endchar;

% box, diamond, circle, box-in-circle, diamond-in-circle (modified by JJW)

box_width#     := 8pt#;
diamond_width# := 10pt#;
circle_width#  := 9pt#;
margin#        := 1pt#;

define_pixels(margin);

pickup pencircle scaled thin_pen_width;
define_good_y_pixels(math_axis);

"\B box";
beginchar(hex "30", box_width#+2margin#, v_center(box_width#));
pickup pencircle scaled thin_pen_width;
bot lft z1 = (margin, -d);		% 4    3
bot rt z2  = (w-margin, -d);		%
top rt z3  = (w-margin, h);		% 1    2
top lft z4 = (margin, h);
draw z1 -- z2 -- z3 -- z4 -- z1;
penlabels(1,2,3,4);
endchar;

"\D diamond";
beginchar(hex "31", diamond_width#+2margin#, v_center(diamond_width#));
pickup pencircle scaled thin_pen_width;
bot z1 = (w/2, -d);			%    3
top z3 = (w/2, h);			% 4     2
lft z4 = (margin, math_axis);		%    1
rt z2  = (w-margin, math_axis);
draw z1 -- z2 -- z3 -- z4 -- z1;
penlabels(1,2,3,4);
endchar;

"\C circle";
beginchar(hex "32", circle_width#+2margin#, v_center(circle_width#));
pickup pencircle scaled thin_pen_width;
bot z1 = (w/2, -d);			%    3
top z3 = (w/2, h);			% 4     2
lft z4 = (margin, math_axis);		%    1
rt z2  = (w-margin, math_axis);
x15=x25=.707[x1,x2];
x35=x45=.707[x1,x4];
y25=y35=.707[y4,y3];
y15=y45=.707[y4,y1];
draw z1{right} ... z15{z2-z1} ... z2{up} ... z25{z3-z2} ... z3{left}
  ... z35{z4-z3} ...  z4{down} ... z45{z1-z4} ... cycle;
penlabels(1,2,3,4,15,25,35,45);
endchar;

"\BinC box-in-circle";
beginchar(hex "33", circle_width#+2margin#, v_center(circle_width#));
pickup pencircle scaled thin_pen_width;
bot z1 = (w/2, -d);			%    3
top z3 = (w/2, h);			% 4     2
lft z4 = (margin, math_axis);		%    1
rt z2  = (w-margin, math_axis);
x15=x25=.707[x1,x2];
x35=x45=.707[x1,x4];
y25=y35=.707[y4,y3];
y15=y45=.707[y4,y1];
z16 = z15 + (thin_pen_width, 0) rotated 135;
z26 = z25 + (thin_pen_width, 0) rotated 225;
z36 = z35 + (thin_pen_width, 0) rotated 315;
z46 = z45 + (thin_pen_width, 0) rotated  45;
draw z1{right} ... z15{z2-z1} ... z2{up} ... z25{z3-z2} ... z3{left}
  ... z35{z4-z3} ...  z4{down} ... z45{z1-z4} ... cycle;
draw z16 -- z26 -- z36 -- z46 -- z16;
penlabels(1,2,3,4,15,25,35,45);
endchar;

"\DinC diamond-in-circle";
beginchar(hex "34", circle_width#+2margin#, v_center(circle_width#));
pickup pencircle scaled thin_pen_width;
bot z1 = (w/2, -d);			%    3
top z3 = (w/2, h);			% 4     2
lft z4 = (margin, math_axis);		%    1
rt z2  = (w-margin, math_axis);
x15=x25=.707[x1,x2];
x35=x45=.707[x1,x4];
y25=y35=.707[y4,y3];
y15=y45=.707[y4,y1];
z16 = z1 + (thin_pen_width, 0) rotated 90;
z26 = z2 + (thin_pen_width, 0) rotated 180;
z36 = z3 + (thin_pen_width, 0) rotated 270;
z46 = z4 + (thin_pen_width, 0) rotated 0;
draw z1{right} ... z15{z2-z1} ... z2{up} ... z25{z3-z2} ... z3{left}
  ... z35{z4-z3} ...  z4{down} ... z45{z1-z4} ... cycle;
draw z16 -- z26 -- z36 -- z46 -- z16;
penlabels(1,2,3,4,15,25,35,45);
endchar;

"\MinC minus-in-circle";
beginchar(hex "13", circle_width#+2margin#, v_center(circle_width#));
pickup pencircle scaled thin_pen_width;
bot z1 = (w/2, -d);			%    3
top z3 = (w/2, h);			% 4     2
lft z4 = (margin, math_axis);		%    1
rt z2  = (w-margin, math_axis);
x15=x25=.707[x1,x2];
x35=x45=.707[x1,x4];
y25=y35=.707[y4,y3];
y15=y45=.707[y4,y1];

z26 = z2 + (thin_pen_width, 0) rotated 180;
z46 = z4 + (thin_pen_width, 0) rotated 0;

z91 = .25 [z46, z26];
z92 = .75 [z46, z26];

draw z1{right} ... z15{z2-z1} ... z2{up} ... z25{z3-z2} ... z3{left}
  ... z35{z4-z3} ...  z4{down} ... z45{z1-z4} ... cycle;
draw z91 -- z92;
penlabels(1,2,3,4,15,25,35,45);
endchar;

"\MinD minus-in-diamond";
beginchar(hex "51", diamond_width#+2margin#, v_center(diamond_width#));
pickup pencircle scaled thin_pen_width;
bot z1 = (w/2, -d);			%    3
top z3 = (w/2, h);			% 4     2
lft z4 = (margin, math_axis);		%    1
rt z2  = (w-margin, math_axis);
z26 = z2 + (thin_pen_width, 0) rotated 180;
z46 = z4 + (thin_pen_width, 0) rotated 0;

z91 = .25 [z46, z26];
z92 = .75 [z46, z26];

draw z1 -- z2 -- z3 -- z4 -- z1;
draw z91 -- z92;
penlabels(1,2,3,4);
endchar;

"\MinB minus-in-box";
beginchar(hex "60", box_width#+2margin#, v_center(box_width#));
pickup pencircle scaled thin_pen_width;
bot lft z1 = (margin, -d);		% 4    3
bot rt z2  = (w-margin, -d);		% 5    6
top rt z3  = (w-margin, h);		% 1    2
top lft z4 = (margin, h);
lft z5 = (margin, math_axis);
rt z6  = (w-margin, math_axis);
z56 = z5 + (thin_pen_width, 0) rotated 0;
z66 = z6 + (thin_pen_width, 0) rotated 180;

z91 = .25 [z56, z66];
z92 = .75 [z56, z66];

draw z1 -- z2 -- z3 -- z4 -- z1;
draw z91 -- z92;
penlabels(1,2,3,4);
endchar;

%%K 2002-10-28: two LTL ops <*> and [*]
"\dotD dot-in-diamond";
beginchar(hex "9A", diamond_width#+2margin#, v_center(diamond_width#));
pickup pencircle scaled thin_pen_width;
bot z1 = (w/2, -d);			%    3
top z3 = (w/2, h);			% 4     2
lft z4 = (margin, math_axis);		%    1
rt z2  = (w-margin, math_axis);
z26 = z2 + (thin_pen_width, 0) rotated 180;
z46 = z4 + (thin_pen_width, 0) rotated 0;

z91 = .5 [z46, z26];
z92 = .5 [z46, z26];

draw z1 -- z2 -- z3 -- z4 -- z1;
pickup pencircle scaled heavy_pen_width;
draw z91 -- z92;
penlabels(1,2,3,4);
endchar;

"\dotB dot-in-box";
beginchar(hex "9B", box_width#+2margin#, v_center(box_width#));
pickup pencircle scaled thin_pen_width;
bot lft z1 = (margin, -d);		% 4    3
bot rt z2  = (w-margin, -d);		% 5    6
top rt z3  = (w-margin, h);		% 1    2
top lft z4 = (margin, h);
lft z5 = (margin, math_axis);
rt z6  = (w-margin, math_axis);
z56 = z5 + (thin_pen_width, 0) rotated 0;
z66 = z6 + (thin_pen_width, 0) rotated 180;

z91 = .5 [z56, z66];
z92 = .5 [z56, z66];

draw z1 -- z2 -- z3 -- z4 -- z1;
pickup pencircle scaled heavy_pen_width;
draw z91 -- z92;
penlabels(1,2,3,4);
endchar;


% modal characters, by EM (modified by JJW)

height#		:= 10pt#;		% height+depth of all symbols here
rect_width#	:= .5 height#;
tip_width#	:= .5 height#;
circ_width#	:= .5 height#;		
equal_offset#	:= .2 rect_width#;	% width of the equal space
thick_width#	:= .15 height#;		% thickness of the thick lines
small_space#	:= .3 height#;		% for unary operators

define_pixels (height, rect_width, equal_offset, tip_width, circ_width, thick_width);

define_pixels(math_axis);		% (we shouldn't need to do this)
modal_mid := round(math_axis);
modal_top := round(modal_mid + .5height);
modal_bot := round(modal_mid - .5height);

def round_pen  = pickup pencircle scaled thin_pen_width enddef;
def square_pen = pickup pensquare scaled thin_pen_width enddef;
def thick_pen  = pickup pensquare scaled thick_width enddef;

% These characters are built out of components that are positionned
% one next to the other. The global variable left_x is the left position
% of the component to place.

def begin_modal_char (expr code, width) =
  beginchar (hex code, width, v_center(height#));
  left_x := 0;
  enddef;

def end_modal_char =
  endchar;
  enddef;

vardef rect@# =
  save x, y;
  square_pen;
  top lft z1 = (left_x, modal_top);
  top rt z2 = (left_x + rect_width, modal_top);
  bot lft z3 = (left_x, modal_bot);
  bot rt z4 = (left_x + rect_width, modal_bot);
  draw z1--z2; draw z3--z4;

  if (str@# = "l") or (str@# = "b"):
     z5 = z1 + (equal_offset, 0);      z6 = z3 + (equal_offset, 0);
     draw z5--z6; fi

  if (str@# = "r") or (str@# = "b"):
     z7 = z2 - (equal_offset, 0);      z8 = z4 - (equal_offset, 0);
     draw z7--z8; fi

  left_x := left_x + rect_width;
  enddef;

def equal =
  save x, y;
  round_pen;
  top z1 = (left_x, modal_top);   z2 = z1 + (equal_offset, 0);
  bot z3 = (left_x, modal_bot);   z4 = z3 + (equal_offset, 0);

  draw z1 -- z2 -- z4 -- z3 -- cycle;
  left_x := left_x + equal_offset;
  enddef;

save bar;
def bar =
  save x, y; round_pen;
  top z1 = (left_x, modal_top); bot z2 = (left_x, modal_bot);
  draw z1 -- z2;
  enddef;

vardef tip@# =
  save x, y;
  round_pen;
  if (str@# = "l"):
    lft z2 = (left_x, modal_mid); top z1 = (left_x + tip_width, modal_top);
  else:
    top z1 = (left_x, modal_top); rt z2 = (left_x + tip_width, modal_mid);
    fi
  x3 = x1;  bot y3 = modal_bot;
  draw z1 -- z2 -- z3;
  left_x := left_x + tip_width;
  enddef;
vardef circ@# =
  save x, y;
  round_pen;

  if (str@# = "l"):
    lft z2 = (left_x, modal_mid); top z1 = (left_x + circ_width, modal_top);
  else:
    top z1 = (left_x, modal_top); rt z2 = (left_x + circ_width, modal_mid);
    fi
  x3 = x1; bot y3 = modal_bot;

  if (str@# = "l"):
    draw z1{left} .. z2{down} .. z3{right};
  else:
    draw z1{right} .. z2{down} .. z3{left};
    fi

   left_x := left_x + circ_width;
  enddef;

def thick_bar =
  save x, y;
  thick_pen;
  top lft z1 = (left_x, modal_top); bot lft z2 = (left_x, modal_bot);
  draw z1 -- z2;
  left_x := left_x + thick_width;
  enddef;

def offset_thick_bar =
  left_x := left_x - thick_width;
  enddef;

"\DR diamond-right";
  begin_modal_char ("20", tip_width#);
    bar; tip.r;
    end_modal_char;

"\DL diamond-left";
  begin_modal_char ("21", tip_width#);
    tip.l; bar;
    end_modal_char;

"\CR";
  begin_modal_char ("22", circ_width#);
    bar; circ.r;
    end_modal_char;

"\CL";
  begin_modal_char ("23", circ_width#);
    circ.l; bar;
    end_modal_char;

"\DRE";
  begin_modal_char ("24", equal_offset#+tip_width#);
    equal; tip.r;
    end_modal_char;

"\DLE";
  begin_modal_char ("25", equal_offset#+tip_width#);
    tip.l; equal;
    end_modal_char;

"\CRE";
  begin_modal_char ("26", equal_offset#+circ_width#);
    equal; circ.r;
    end_modal_char;

"\CLE";
  begin_modal_char ("27", equal_offset#+circ_width#);
    circ.l; equal;
    end_modal_char;

"\BD";
  begin_modal_char ("28", rect_width#+tip_width#);
    bar; rect; bar; tip.r;
    end_modal_char;

"\DB";
  begin_modal_char ("29", rect_width#+tip_width#);
    tip.l; bar; rect; bar;
    end_modal_char;

"\BC";
  begin_modal_char ("2A", rect_width#+circ_width#);
    bar; rect; bar; circ.r;
    end_modal_char;

"\CB";
  begin_modal_char ("2B", rect_width#+circ_width#);
    circ.l; bar; rect; bar;
    end_modal_char;

"\BDE";
  begin_modal_char ("2C", rect_width#+tip_width#);
    bar; rect.l; bar; tip.r;
    end_modal_char;

"\DBE";
  begin_modal_char ("2D", rect_width#+tip_width#);
    tip.l; bar; rect.r; bar;
    end_modal_char;

"\BCE";
  begin_modal_char ("2E", rect_width#+circ_width#);
    bar; rect.l; bar; circ.r;
    end_modal_char;

"\CBE";
  begin_modal_char ("2F", rect_width#+circ_width#);
    circ.l; bar; rect.r; bar;
    end_modal_char;

"\FD";
  begin_modal_char ("35", thick_width#+tip_width#);
    thick_bar; tip.r; 
    end_modal_char;

"\PD";
  begin_modal_char ("36", thick_width#+tip_width#);
    tip.l; thick_bar; 
    end_modal_char;

"\FB";
  begin_modal_char ("37", thick_width#+rect_width#+small_space#);
    thick_bar; rect; bar;
    end_modal_char;

"\PB";
  begin_modal_char ("38", thick_width#+rect_width#+small_space#);
    bar; rect; thick_bar; 
    end_modal_char;

"\FBE";
  begin_modal_char ("39", rect_width#+equal_offset#);
    equal; rect; bar;
    end_modal_char;

"\PBE";
  begin_modal_char ("3A", rect_width#+equal_offset#);
    bar; rect; equal;
    end_modal_char;

"\FU";
  begin_modal_char ("3B", rect_width#+tip_width#);
    thick_bar; offset_thick_bar; rect; bar; tip.r;
    end_modal_char;

"\PU";
  begin_modal_char ("3C", rect_width#+tip_width#);
    tip.l; bar; rect; offset_thick_bar; thick_bar;
    end_modal_char;

"\FS";
  begin_modal_char ("3D", rect_width#+tip_width#);
    thick_bar; offset_thick_bar; rect; tip.r;
    end_modal_char;

"\PS";
  begin_modal_char ("3E", rect_width#+tip_width#);
    tip.l; rect; offset_thick_bar; thick_bar;
    end_modal_char;

"\FC";
  begin_modal_char ("3F", thick_width#+circ_width#);
    thick_bar; circ.r;
    end_modal_char;

"\PC";
  begin_modal_char ("40", thick_width#+circ_width#);
    circ.l; thick_bar;
    end_modal_char;

"\FSE";
  begin_modal_char ("41", rect_width#+tip_width#);
    bar; rect.l; tip.r;
    end_modal_char;

"\PSE";
  begin_modal_char ("42", rect_width#+tip_width#);
    tip.l; rect.r; bar;
    end_modal_char;

"\BDEE";
  begin_modal_char ("52", rect_width#+tip_width#);
    bar; rect.b; bar; tip.r;
    end_modal_char;

"\DBEE";
  begin_modal_char ("53", rect_width#+tip_width#);
    tip.l; bar; rect.b; bar;
    end_modal_char;

"\BCEE";
  begin_modal_char ("54", rect_width#+circ_width#);
    bar; rect.b; bar; circ.r;
    end_modal_char;

"\CBEE";
  begin_modal_char ("55", rect_width#+circ_width#);
    circ.l; bar; rect.b; bar;
    end_modal_char;

"\VD";
  begin_modal_char ("56", tip_width#+small_space#);
    bar; tip.l; bar;
    end_modal_char;

"\VC";
  begin_modal_char ("57", circ_width#+small_space#);
    bar; circ.l; bar;
    end_modal_char;

"\DV";
  begin_modal_char ("58", tip_width#+small_space#);
    bar; tip.r; bar;
    end_modal_char;

"\CV";
  begin_modal_char ("59", circ_width#+small_space#);
    bar; circ.r; bar;
    end_modal_char;

% Tiny relations and arrows to put inside modal operators (by JJW)

width# := 2.8pt#;		% width of all these symbols
height# := 4.2pt#;		% height of relations
sep# := 1.1pt#;			% separation for relations
arrow_sep# := 1.1pt#;		% space between bars of double arrow
single_arrow_head_height# := 1.1pt#;
double_arrow_head_height# := 1.4pt#;

define_whole_pixels(sep, arrow_sep,
	single_arrow_head_height, double_arrow_head_height);

pickup pencircle scaled thin_pen_width;
define_good_y_pixels(math_axis);

beginchar(hex "18", width#, math_axis#+single_arrow_head_height#, 0);
"tiny left arrow";
pickup pencircle scaled thin_pen_width;
x1=w; x2=0; y1=y2=math_axis;
x3=x4=x2+single_arrow_head_height;
y3-y2=y2-y4=single_arrow_head_height;
draw z1 -- z2;
draw z3 -- z2 -- z4;
penlabels(1,2,3,4);
endchar;

beginchar(hex "19", width#, math_axis#+single_arrow_head_height#, 0);
"tiny right arrow";
pickup pencircle scaled thin_pen_width;
x1=0; x2=w; y1=y2=math_axis;
x3=x4=x2-single_arrow_head_height;
y3-y2=y2-y4=single_arrow_head_height;
draw z1 -- z2;
draw z3 -- z2 -- z4;
penlabels(1,2,3,4);
endchar;

beginchar(hex "1A", width#, math_axis#+double_arrow_head_height#, 0);
"tiny left double arrow";
pickup pencircle scaled thin_pen_width;
x7=0; x1=x2=w;
y7=math_axis;
x3=x4=x7+double_arrow_head_height;
y3-y7=y7-y4=double_arrow_head_height;
y5-y7=y7-y6=.5arrow_sep;
z5=whatever[z3,z7];
z6=whatever[z4,z7];
y1=y5; y2=y6;
draw z1 -- z5; draw z2 -- z6;
draw z3 -- z7 -- z4;
penlabels(1,2,3,4,5,6,7);
endchar;

beginchar(hex "1B", width#, math_axis#+double_arrow_head_height#, 0);
"tiny right double arrow";
pickup pencircle scaled thin_pen_width;
x7=w; x1=x2=0;
y7=math_axis;
x3=x4=x7-double_arrow_head_height;
y3-y7=y7-y4=double_arrow_head_height;
y5-y7=y7-y6=.5arrow_sep;
z5=whatever[z3,z7];
z6=whatever[z4,z7];
y1=y5; y2=y6;
draw z1 -- z5; draw z2 -- z6;
draw z3 -- z7 -- z4;
penlabels(1,2,3,4,5,6,7);
endchar;

beginchar(hex "1C", width#, height#, 0);
"tiny less than sign";
pickup pencircle scaled thin_pen_width;
x1=x3=w; x2=0;
y1=h-.2sep;			% fudge factor makes < look better
y2=math_axis; y1-y2=y2-y3;
draw z1 -- z2 -- z3;
penlabels(1,2,3);
endchar;

beginchar(hex "1D", width#, height#, 0);
"tiny greater than sign";
pickup pencircle scaled thin_pen_width;
x1=x3=0; x2=w;
y1=h-.2sep;			% fudge factor makes > look better
y2=math_axis; y1-y2=y2-y3;
draw z1 -- z2 -- z3;
penlabels(1,2,3);
endchar;

beginchar(hex "1E", width#, height#, 0);
"tiny less than or equal to sign";
pickup pencircle scaled thin_pen_width;
x1=x3=w; x2=0; x4=x2; x5=x3;
y1=h; y1-y2=y2-y3; y2-y4=y3-y5=sep;
y1+y5=2*math_axis;
draw z1 -- z2 -- z3;
draw z4 -- z5;
penlabels(1,2,3,4,5);
endchar;

beginchar(hex "1F", width#, height#, 0);
"tiny greater than or equal to sign";
pickup pencircle scaled thin_pen_width;
x1=x3=0; x2=w; x4=x2; x5=x3;
y1=h; y1-y2=y2-y3; y2-y4=y3-y5=sep;
y1+y5=2*math_axis;
draw z1 -- z2 -- z3;
draw z4 -- z5;
penlabels(1,2,3,4,5);
endchar;

%% arcs and arrowheads for reac figures by em
 
def define_round_pixels(text t) =
 forsuffixes $=t: $:=ceiling($.#*hppp);
% $.#:=$/hppp;
% JJW took out above line 11/5/88
 endfor enddef;

thickness#:=.8pt#;

define_round_pixels(thickness);

pickup pencircle scaled thickness; nib:=savepen;


% arcs sets up the points 1, 2, ..., 8 as follows:
%
%            1
%           * *
%          8 |  2
%         *  |  *
%        7   |   3
%      --*-------*--
%         6  |  4
%           * *
%            5
%
%        <----w---->

pair upleft,upright,downleft,downright;
upright=-downleft=(1,1); downright=-upleft=(1,-1);

def qbeginchar (expr c, diam_sharp) =
numeric hh, dd; hh:=.5*(diam_sharp+thickness#);
dd:=.5*(diam_sharp+thickness#);
beginchar(c,diam_sharp,hh,dd);
enddef;

def arcs =
numeric delta;
delta:=.5*0.707*w; % distance from axis to arc's 45 degree points
y3=0; y7=y3=.5[y5,y1]; y1-y5=w;
x1=0; x5=x1=.5[x7,x3]; x3-x7=w;
x2-x1=delta; x1-x8=delta; x8=x6; x2=x4;
y8-y7=delta; y7-y6=delta; y8=y2; y6=y4;
enddef;

def darcs (expr bigww, smallww) =
numeric bigdelta, smalldelta;
numeric bigw, smallw;
bigw:=hround(bigww * hppp);
smallw:=hround(smallww * hppp);
bigdelta:=.5*bigw*0.707; % distance from axis to arc's 45 degree points
y3=0; y7=y3=.5[y5,y1]; y1-y5=bigw;
x1=0; x5=x1=.5[x7,x3]; x3-x7=bigw;
x2-x1=bigdelta; x1-x8=bigdelta; x8=x6; x2=x4;
y8-y7=bigdelta; y7-y6=bigdelta; y8=y2; y6=y4;
smalldelta:=.5*smallw*0.707; % distance from axis to arc's 45 degree points
y13=0; y17=y13=.5[y15,y11]; y11-y15=smallw;
x11=0; x15=x11=.5[x17,x13]; x13-x17=smallw;
x12-x11=smalldelta; x11-x18=smalldelta; x18=x16; x12=x14;
y18-y17=smalldelta; y17-y16=smalldelta; y18=y12; y16=y14;
enddef;

"single, top right";
qbeginchar(hex "00",18pt#);
numeric delta;
pickup nib;
arcs;
draw z1{right}..z2{downright}..z3{down};
endchar;

"single, bottom right";
qbeginchar(hex "01",18pt#);
numeric delta;
pickup nib;
arcs;
draw z3{down}..z4{downleft}..z5{left};
endchar;

"single, bottom left";
qbeginchar(hex "02",18pt#);
numeric delta;
pickup nib;
arcs;
draw z5{left}..z6{upleft}..z7{up};
endchar;

"single, top left";
qbeginchar(hex "03",18pt#);
numeric delta;
pickup nib;
arcs;
draw z7{up}..z8{upright}..z1{right};
endchar;

"double, top right";
qbeginchar(hex "04",18pt#);
numeric delta;
pickup nib;
darcs(16pt#,20pt#);
draw z1{right}..z2{downright}..z3{down};
draw z11{right}..z12{downright}..z13{down};
endchar;

"double, bottom right";
qbeginchar(hex "05",18pt#);
numeric delta;
pickup nib;
darcs(16pt#,20pt#);
draw z3{down}..z4{downleft}..z5{left};
draw z13{down}..z14{downleft}..z15{left};
endchar;

"double, bottom left";
qbeginchar(hex "06",18pt#);
numeric delta;
pickup nib;
darcs(16pt#,20pt#);
draw z5{left}..z6{upleft}..z7{up};
draw z15{left}..z16{upleft}..z17{up};
endchar;

"double, top left";
qbeginchar(hex "07",18pt#);
numeric delta;
pickup nib;
darcs(16pt#,20pt#);
draw z7{up}..z8{upright}..z1{right};
draw z17{up}..z18{upright}..z11{right};
endchar;

qqs#=.8pt#;   %width of lines
qqw#=10pt#;
arrowlen#=4pt#; arrowht#=3.5pt#; arrowcurve#=2.5pt#; arrowext#=6pt#;
arrowmeet#=.8pt#;

define_round_pixels(qqs,qqw,arrowlen,arrowht,arrowcurve,arrowext,arrowmeet);


"left arrowhead (double)";
beginchar(hex "0C",qqw#,qqw#,0pt#);
x2=arrowlen;	y2=arrowht;		x3=x2; y3=-y2;
x4=arrowcurve;  y4=arrowmeet;		x5=x4; y5=-y4;
x0=arrowext; 	y0=y4;			x1=x0; y1=-y0;
pickup nib;
draw z2{down}..z4{downleft}..(0,0){left};
draw z3{up}..z5{upleft}..(0,0){left};
draw z0--z4;
draw z1--z5;
endchar;

"right arrowhead (double)";  %right arrow
beginchar(hex "0D",qqw#,qqw#,0pt#);
x2=-arrowlen;	y2=arrowht;		x3=x2; y3=-y2;
x4=-arrowcurve; y4=arrowmeet;		x5=x4; y5=-y4;
x0=-arrowext; 	y0=y4;			x1=x0; y1=-y0;
pickup nib;
draw z2{down}..z4{downright}..(0,0){right};
draw z3{up}..z5{upright}..(0,0){right};
draw z0--z4;
draw z1--z5;
endchar;

"up arrowhead (double)";
beginchar(hex "0E",qqw#,qqw#,0pt#);
y2=-arrowlen;	x2=arrowht;		y3=y2; x3=-x2;
y4=-arrowcurve;	x4=arrowmeet;		y5=y4; x5=-x4;
y0=-arrowext; 	x0=x4;			y1=y0; x1=-x0;
pickup nib;
draw z2{left}..z4{upleft}..(0,0){up};
draw z3{right}..z5{upright}..(0,0){up};
draw z0--z4;
draw z1--z5;
endchar;

"down arrowhead (double)";
beginchar(hex "0F",qqw#,qqw#,0pt#);
y2=arrowlen;	x2=arrowht;		y3=y2; x3=-x2;
y4=arrowcurve;	x4=arrowmeet;		y5=y4; x5=-x4;
y0=arrowext;	x0=x4;			y1=y0; x1=-x0;
pickup nib;
draw z2{left}..z4{downleft}..(0,0){down};
draw z3{right}..z5{downright}..(0,0){down};
draw z0--z4;
draw z1--z5;
endchar;

thickness#:=2.4pt#;

thickness:=ceiling(thickness#*hppp); % the way rules thicknesses are done
% thickness#:=thickness/hppp; % and let thickness# round to right value
% JJW took out above line 11/5/88
pickup pencircle scaled thickness; nib:=savepen;


"triple, top right";
qbeginchar(hex "08",18pt#);
numeric delta;
pickup nib;
arcs;
draw z1{right}..z2{downright}..z3{down};
endchar;

"triple, bottom right";
qbeginchar(hex "09",18pt#);
numeric delta;
pickup nib;
arcs;
draw z3{down}..z4{downleft}..z5{left};
endchar;

"triple, bottom left";
qbeginchar(hex "0A",18pt#);
numeric delta;
pickup nib;
arcs;
draw z5{left}..z6{upleft}..z7{up};
endchar;

"triple, top left";
qbeginchar(hex "0B" ,18pt#);
numeric delta;
pickup nib;
arcs;
draw z7{up}..z8{upright}..z1{right};
endchar;



"high solid triangle pointing left";
  beginchar (hex "10", .3 height#, v_center(height#));
  round_pen;
  lft z2 = (0, modal_mid); top z1 = (.3 height, modal_top);
  x3 = x1;  bot y3 = modal_bot;
  fill z1 -- z2 -- z3 -- cycle;
  endchar;

"small diamond";
  beginchar (hex "11", .6 height#, v_center(height#));
  round_pen;
  lft z2 = (0, modal_mid); top z1 = (.3 height, modal_mid+.3 height);
  rt  z3 = (.6 height, modal_mid); bot z4 = (.3 height, modal_mid-.3 height);
  fill z1 -- z2 -- z4 -- z3 -- cycle;
  endchar;

% Characters following this point use CMBASE macros

endgroup;			% see comment at beginning of file

cmchar "Occurs sign";
compute_spread(5/4x_height#,3/2x_height#);
beginchar(hex"014",14u#,v_center(spread#+rule_thickness#));
adjust_fit(0,0); pickup rule.nib; autorounded;
lft x2=hround 1.5u-epsilon; x1=x3=w-x2;
y1-y3=spread; y2=.5[y1,y3]; top y1=h;
draw z1{-u,-spread}...{left}z2;	% upper diagonal
draw z3{-u,spread}...{left}z2;	% lower diagonal
x4=x1; y4=y2; draw z2--z4;	% center bar
labels(1,2,3,4); endchar;

cmchar "Contains sign";
compute_spread(5/4x_height#,3/2x_height#);
beginchar(hex"015",14u#,v_center(spread#+rule_thickness#));
adjust_fit(0,0); pickup rule.nib; autorounded;
lft x1=hround 1.5u-epsilon; x2=w-x1; x3=x1;
y1-y3=spread; y2=.5[y1,y3]; top y1=h;
draw z1{u,-spread}...{right}z2;	% upper diagonal
draw z3{u,spread}...{right}z2;	% lower diagonal
x4=x1; y4=y2; draw z2--z4;	% center bar
labels(1,2,3,4); endchar;

cmchar "Occurs or equals sign";
compute_spread(.45x_height#,.55x_height#);
spread#':=spread#; spread':=spread; % the spread of `$=$'
compute_spread(5/4x_height#,3/2x_height#);
beginchar(hex"016",14u#,v_center(spread#'+spread#+rule_thickness#));
adjust_fit(0,0); pickup rule.nib; autorounded;
lft x2=hround 1.5u-eps; x1=x3=w-x2;
y1-y3=spread; y2=.5[y1,y3]; top y1=h;
draw z1{-u,-spread}...{left}z2;	% upper diagonal
draw z3{-u,spread}...{left}z2;	% lower diagonal
x4=x1; y4=y2; draw z2--z4;	% center bar
x8=x1; x9=x2; y8=y9; y3-y9=spread'; draw z8--z9;	% bar
labels(1,2,3,4,8,9); endchar;

cmchar "Contains or equals sign";
compute_spread(.45x_height#,.55x_height#);
spread#':=spread#; spread':=spread; % the spread of `$=$'
compute_spread(5/4x_height#,3/2x_height#);
beginchar(hex"017",14u#,v_center(spread#'+spread#+rule_thickness#));
adjust_fit(0,0); pickup rule.nib; autorounded;
lft x1=hround 1.5u-eps; x2=w-x1; x3=x1;
y1-y3=spread; y2=.5[y1,y3]; top y1=h;
draw z1{u,-spread}...{right}z2;	% upper diagonal
draw z3{u,spread}...{right}z2;	% lower diagonal
x4=x1; y4=y2; draw z2--z4;	% center bar
x8=x1; x9=x2; y8=y9; y3-y9=spread'; draw z8--z9;	% bar
labels(1,2,3,4,8,9); endchar;
end.

% (The remainder of this page is not read.)

% translines			(0)(1)(2)(3)

new alength, blength, fudge, arrowlen;
new w0, w1;

w0 = .5pt;
w1 = 1pt;

alength = alen.pt;		% see global constants;
arrowlen = (sqrt(1 + 3.5*3.5))pt;
fudge = circradius.(1-sqrt(.5));
.

subroutine dotrans(var length):
    cpen;					%	2
    lft1 x1 = bot1 y1 = -fudge;			%
%   top0 y2 = rt0 x2 = length + fudge;		%  4
						%  1 3
%   w0 draw 1..2;

    x3 = x1 + arrowlen;  y3 = y1;
    x4 = x1;  y4 = y1 + arrowlen;

    w1 draw 1..3;
    draw 1..4;
    call unflip;
    call charinfo(0, 0, 0);
%   call charinfo(length, length, 0);
.

%"diagonal arrows";
%"0"; charcode `0; call dotrans(alength).
%"1"; charcode `1; call flipx(alength/2); call dotrans(alength).
%"2"; charcode `2; call flipy(alength/2); call dotrans(alength).
%"3"; charcode `3;
%	call flipx(alength/2); call flipy(alength/2); call dotrans(alength).

"diagonal arrows";
"0"; charcode `0; call dotrans(0).
"1"; charcode `1; call flipx(0); call dotrans(0).
"2"; charcode `2; call flipy(0); call dotrans(0).
"3"; charcode `3;
	call flipx(0); call flipy(0); call dotrans(0).
